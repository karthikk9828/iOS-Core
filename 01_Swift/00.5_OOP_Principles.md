# OOP Principles in Swift

This document covers all major Object-Oriented Programming (OOP) principles in Swift with practical examples.

## Table of Contents

### Core 4 Principles
1. [Encapsulation](#encapsulation)
2. [Inheritance](#inheritance)
3. [Polymorphism](#polymorphism)
4. [Abstraction](#abstraction)

### Additional OOP Principles
5. [Association](#association)
6. [Aggregation](#aggregation)
7. [Composition](#composition)

### Design Principles
8. [Coupling and Cohesion](#coupling-and-cohesion)
9. [Message Passing](#message-passing)

---

## Quick Reference: Relationships Comparison

| Relationship | Type | Lifecycle | Example | Keyword |
|-------------|------|-----------|---------|---------|
| **Association** | Independent | Separate | Teacher-Student, Driver-Car | "uses-a" |
| **Aggregation** | Weak ownership | Children can exist alone | Department-Employee, Library-Books | "has-a" |
| **Composition** | Strong ownership | Children destroyed with parent | House-Rooms, Car-Engine | "part-of" |

---

## 1. Encapsulation

**Definition**: Encapsulation is the bundling of data (properties) and methods that operate on that data within a single unit (class/struct), and restricting direct access to some of the object's components.

### Key Concepts:
- Hide internal implementation details
- Use access control (private, public, internal, etc.)
- Provide controlled access through methods

### Example:

```swift
class BankAccount {
    // Private property - cannot be accessed directly from outside
    private var balance: Double = 0.0
    
    // Public property - can be accessed from outside
    let accountNumber: String
    
    init(accountNumber: String, initialBalance: Double) {
        self.accountNumber = accountNumber
        self.balance = initialBalance
    }
    
    // Public method to deposit money
    func deposit(amount: Double) {
        guard amount > 0 else {
            print("Invalid amount")
            return
        }
        balance += amount
        print("Deposited: $\(amount). New balance: $\(balance)")
    }
    
    // Public method to withdraw money
    func withdraw(amount: Double) -> Bool {
        guard amount > 0 && amount <= balance else {
            print("Invalid withdrawal amount or insufficient funds")
            return false
        }
        balance -= amount
        print("Withdrawn: $\(amount). New balance: $\(balance)")
        return true
    }
    
    // Public method to check balance
    func getBalance() -> Double {
        return balance
    }
}

// Usage
let account = BankAccount(accountNumber: "123456", initialBalance: 1000.0)
account.deposit(amount: 500.0)        // ‚úÖ Works
account.withdraw(amount: 200.0)       // ‚úÖ Works
print(account.getBalance())           // ‚úÖ Works
// account.balance = 5000.0           // ‚ùå Error: 'balance' is inaccessible
```

### Benefits:
- Data protection and validation
- Flexibility to change internal implementation
- Easier maintenance and debugging

---

## 2. Inheritance

**Definition**: Inheritance allows a class to inherit properties and methods from another class, promoting code reuse and establishing a hierarchical relationship.

### Key Concepts:
- Parent class (superclass) and child class (subclass)
- Subclass inherits all properties and methods
- Use `override` keyword to modify inherited behavior
- Use `final` to prevent inheritance

### Example:

```swift
// Parent class (Base class)
class Vehicle {
    var brand: String
    var year: Int
    var currentSpeed: Double = 0.0
    
    init(brand: String, year: Int) {
        self.brand = brand
        self.year = year
    }
    
    func accelerate(by speed: Double) {
        currentSpeed += speed
        print("\(brand) is now moving at \(currentSpeed) km/h")
    }
    
    func stop() {
        currentSpeed = 0.0
        print("\(brand) has stopped")
    }
    
    func displayInfo() {
        print("Brand: \(brand), Year: \(year)")
    }
}

// Child class 1: Car inherits from Vehicle
class Car: Vehicle {
    var numberOfDoors: Int
    
    init(brand: String, year: Int, numberOfDoors: Int) {
        self.numberOfDoors = numberOfDoors
        super.init(brand: brand, year: year)
    }
    
    // Override parent method
    override func displayInfo() {
        super.displayInfo()  // Call parent's implementation
        print("Type: Car, Doors: \(numberOfDoors)")
    }
    
    // New method specific to Car
    func honk() {
        print("Beep beep! üöó")
    }
}

// Child class 2: Motorcycle inherits from Vehicle
class Motorcycle: Vehicle {
    var hasWindshield: Bool
    
    init(brand: String, year: Int, hasWindshield: Bool) {
        self.hasWindshield = hasWindshield
        super.init(brand: brand, year: year)
    }
    
    // Override parent method
    override func displayInfo() {
        super.displayInfo()
        print("Type: Motorcycle, Windshield: \(hasWindshield ? "Yes" : "No")")
    }
    
    // New method specific to Motorcycle
    func wheelie() {
        print("Performing a wheelie! üèçÔ∏è")
    }
}

// Usage
let tesla = Car(brand: "Tesla", year: 2023, numberOfDoors: 4)
tesla.displayInfo()
tesla.accelerate(by: 60.0)
tesla.honk()

print("\n")

let harley = Motorcycle(brand: "Harley-Davidson", year: 2022, hasWindshield: false)
harley.displayInfo()
harley.accelerate(by: 80.0)
harley.wheelie()
```

### Preventing Inheritance:

```swift
final class ElectricCar: Car {
    let batteryCapacity: Int
    
    init(brand: String, year: Int, numberOfDoors: Int, batteryCapacity: Int) {
        self.batteryCapacity = batteryCapacity
        super.init(brand: brand, year: year, numberOfDoors: numberOfDoors)
    }
}

// class FutureCar: ElectricCar { }  // ‚ùå Error: Cannot inherit from final class
```

---

## 3. Polymorphism

**Definition**: Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables a single interface to represent different underlying forms (data types).

### Types of Polymorphism:
1. **Compile-time Polymorphism** (Method Overloading)
2. **Runtime Polymorphism** (Method Overriding)

### Example 1: Method Overriding (Runtime Polymorphism)

```swift
class Animal {
    var name: String
    
    init(name: String) {
        self.name = name
    }
    
    func makeSound() {
        print("Some generic animal sound")
    }
    
    func eat() {
        print("\(name) is eating")
    }
}

class Dog: Animal {
    override func makeSound() {
        print("\(name) says: Woof! Woof! üêï")
    }
}

class Cat: Animal {
    override func makeSound() {
        print("\(name) says: Meow! üê±")
    }
}

class Cow: Animal {
    override func makeSound() {
        print("\(name) says: Moo! üêÑ")
    }
}

// Polymorphism in action
let animals: [Animal] = [
    Dog(name: "Buddy"),
    Cat(name: "Whiskers"),
    Cow(name: "Bessie"),
    Dog(name: "Max")
]

// Same method call, different behavior based on object type
for animal in animals {
    animal.makeSound()  // Polymorphic behavior
}
```

### Example 2: Protocol-Based Polymorphism

```swift
protocol Drawable {
    func draw()
}

class Circle: Drawable {
    var radius: Double
    
    init(radius: Double) {
        self.radius = radius
    }
    
    func draw() {
        print("Drawing a circle with radius \(radius)")
    }
}

class Rectangle: Drawable {
    var width: Double
    var height: Double
    
    init(width: Double, height: Double) {
        self.width = width
        self.height = height
    }
    
    func draw() {
        print("Drawing a rectangle \(width)x\(height)")
    }
}

class Triangle: Drawable {
    var base: Double
    var height: Double
    
    init(base: Double, height: Double) {
        self.base = base
        self.height = height
    }
    
    func draw() {
        print("Drawing a triangle with base \(base) and height \(height)")
    }
}

// Polymorphism through protocol
let shapes: [Drawable] = [
    Circle(radius: 5.0),
    Rectangle(width: 10.0, height: 20.0),
    Triangle(base: 8.0, height: 12.0)
]

for shape in shapes {
    shape.draw()  // Each shape draws itself differently
}
```

### Example 3: Method Overloading (Compile-time Polymorphism)

```swift
class Calculator {
    // Add two integers
    func add(_ a: Int, _ b: Int) -> Int {
        return a + b
    }
    
    // Add three integers
    func add(_ a: Int, _ b: Int, _ c: Int) -> Int {
        return a + b + c
    }
    
    // Add two doubles
    func add(_ a: Double, _ b: Double) -> Double {
        return a + b
    }
    
    // Add array of integers
    func add(_ numbers: [Int]) -> Int {
        return numbers.reduce(0, +)
    }
}

let calc = Calculator()
print(calc.add(5, 10))              // 15
print(calc.add(5, 10, 15))          // 30
print(calc.add(5.5, 10.5))          // 16.0
print(calc.add([1, 2, 3, 4, 5]))    // 15
```

---

## 4. Abstraction

**Definition**: Abstraction is the process of hiding complex implementation details and showing only the necessary features of an object. It focuses on what an object does rather than how it does it.

### Key Concepts:
- Use protocols to define abstract interfaces
- Hide implementation complexity
- Provide simple, clear interfaces

### Example 1: Using Protocols for Abstraction

```swift
// Abstract interface
protocol PaymentMethod {
    var name: String { get }
    func processPayment(amount: Double) -> Bool
    func refund(amount: Double) -> Bool
}

// Concrete implementation 1
class CreditCard: PaymentMethod {
    var name: String = "Credit Card"
    private var cardNumber: String
    private var cvv: String
    
    init(cardNumber: String, cvv: String) {
        self.cardNumber = cardNumber
        self.cvv = cvv
    }
    
    func processPayment(amount: Double) -> Bool {
        print("Processing credit card payment of $\(amount)")
        // Complex credit card processing logic hidden here
        print("Validating card \(maskCardNumber())...")
        print("Payment successful!")
        return true
    }
    
    func refund(amount: Double) -> Bool {
        print("Refunding $\(amount) to credit card")
        return true
    }
    
    private func maskCardNumber() -> String {
        let lastFour = String(cardNumber.suffix(4))
        return "**** **** **** \(lastFour)"
    }
}

// Concrete implementation 2
class PayPal: PaymentMethod {
    var name: String = "PayPal"
    private var email: String
    
    init(email: String) {
        self.email = email
    }
    
    func processPayment(amount: Double) -> Bool {
        print("Processing PayPal payment of $\(amount)")
        // Complex PayPal processing logic hidden here
        print("Sending payment to \(email)...")
        print("Payment successful!")
        return true
    }
    
    func refund(amount: Double) -> Bool {
        print("Refunding $\(amount) to PayPal account \(email)")
        return true
    }
}

// Concrete implementation 3
class ApplePay: PaymentMethod {
    var name: String = "Apple Pay"
    private var deviceToken: String
    
    init(deviceToken: String) {
        self.deviceToken = deviceToken
    }
    
    func processPayment(amount: Double) -> Bool {
        print("Processing Apple Pay payment of $\(amount)")
        // Complex Apple Pay processing logic hidden here
        print("Authenticating with Face ID...")
        print("Payment successful!")
        return true
    }
    
    func refund(amount: Double) -> Bool {
        print("Refunding $\(amount) to Apple Pay")
        return true
    }
}

// High-level class using abstraction
class PaymentProcessor {
    func checkout(amount: Double, using paymentMethod: PaymentMethod) {
        print("\n--- Processing Payment via \(paymentMethod.name) ---")
        if paymentMethod.processPayment(amount: amount) {
            print("Thank you for your purchase!")
        } else {
            print("Payment failed. Please try again.")
        }
    }
}

// Usage - User doesn't need to know implementation details
let processor = PaymentProcessor()

let creditCard = CreditCard(cardNumber: "1234567890123456", cvv: "123")
processor.checkout(amount: 99.99, using: creditCard)

let paypal = PayPal(email: "user@example.com")
processor.checkout(amount: 149.99, using: paypal)

let applePay = ApplePay(deviceToken: "ABC123XYZ")
processor.checkout(amount: 199.99, using: applePay)
```

### Example 2: Abstract Data Layer

```swift
// Abstract interface for data storage
protocol DataStorage {
    func save(key: String, value: String)
    func load(key: String) -> String?
    func delete(key: String)
}

// Implementation 1: UserDefaults
class UserDefaultsStorage: DataStorage {
    func save(key: String, value: String) {
        print("Saving to UserDefaults: \(key)")
        UserDefaults.standard.set(value, forKey: key)
    }
    
    func load(key: String) -> String? {
        print("Loading from UserDefaults: \(key)")
        return UserDefaults.standard.string(forKey: key)
    }
    
    func delete(key: String) {
        print("Deleting from UserDefaults: \(key)")
        UserDefaults.standard.removeObject(forKey: key)
    }
}

// Implementation 2: File System
class FileStorage: DataStorage {
    private let directory: URL
    
    init() {
        directory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    }
    
    func save(key: String, value: String) {
        print("Saving to file system: \(key)")
        let fileURL = directory.appendingPathComponent(key)
        try? value.write(to: fileURL, atomically: true, encoding: .utf8)
    }
    
    func load(key: String) -> String? {
        print("Loading from file system: \(key)")
        let fileURL = directory.appendingPathComponent(key)
        return try? String(contentsOf: fileURL, encoding: .utf8)
    }
    
    func delete(key: String) {
        print("Deleting from file system: \(key)")
        let fileURL = directory.appendingPathComponent(key)
        try? FileManager.default.removeItem(at: fileURL)
    }
}

// High-level class that uses abstraction
class UserPreferences {
    private let storage: DataStorage
    
    init(storage: DataStorage) {
        self.storage = storage
    }
    
    func saveUsername(_ username: String) {
        storage.save(key: "username", value: username)
    }
    
    func loadUsername() -> String? {
        return storage.load(key: "username")
    }
}

// Usage - Easy to switch between storage implementations
let userDefaultsPrefs = UserPreferences(storage: UserDefaultsStorage())
userDefaultsPrefs.saveUsername("JohnDoe")

let filePrefs = UserPreferences(storage: FileStorage())
filePrefs.saveUsername("JaneDoe")
```

---

## 5. Association

**Definition**: Association represents a relationship between two or more objects where objects have their own lifecycle and there is no ownership. It's a "uses-a" relationship.

### Key Concepts:
- Objects are independent
- One object uses or interacts with another
- No ownership or lifecycle dependency
- Can be one-to-one, one-to-many, or many-to-many

### Example:

```swift
// Teacher class
class Teacher {
    var name: String
    var subject: String
    
    init(name: String, subject: String) {
        self.name = name
        self.subject = subject
    }
    
    func teach(student: Student) {
        print("\(name) is teaching \(subject) to \(student.name)")
    }
}

// Student class
class Student {
    var name: String
    var grade: Int
    
    init(name: String, grade: Int) {
        self.name = name
        self.grade = grade
    }
    
    func learn(from teacher: Teacher) {
        print("\(name) is learning \(teacher.subject) from \(teacher.name)")
    }
}

// Association: Teacher and Student have independent lifecycles
let teacher = Teacher(name: "Ms. Johnson", subject: "Mathematics")
let student1 = Student(name: "Alice", grade: 10)
let student2 = Student(name: "Bob", grade: 10)

// They can interact but exist independently
teacher.teach(student: student1)
student2.learn(from: teacher)

// Both can exist without each other
```

### Real-World Example: Driver and Car

```swift
class Driver {
    var name: String
    var licenseNumber: String
    
    init(name: String, licenseNumber: String) {
        self.name = name
        self.licenseNumber = licenseNumber
    }
    
    func drive(car: Car) {
        print("\(name) is driving \(car.model)")
    }
}

class Car {
    var model: String
    var year: Int
    
    init(model: String, year: Int) {
        self.model = model
        self.year = year
    }
}

// Association - Driver uses Car, but both exist independently
let driver = Driver(name: "John", licenseNumber: "DL12345")
let car = Car(model: "Tesla Model 3", year: 2023)

driver.drive(car: car)
// Driver can drive different cars, car can be driven by different drivers
```

---

## 6. Aggregation

**Definition**: Aggregation is a specialized form of association representing a "has-a" relationship where the child can exist independently of the parent. It's a weak relationship.

### Key Concepts:
- "Has-a" relationship
- Child can exist without parent
- Weak ownership
- Parent contains references to children

### Example:

```swift
// Department has many Employees, but Employees can exist without Department
class Employee {
    var name: String
    var position: String
    var id: String
    
    init(name: String, position: String, id: String) {
        self.name = name
        self.position = position
        self.id = id
    }
    
    func displayInfo() {
        print("Employee: \(name), Position: \(position), ID: \(id)")
    }
}

class Department {
    var name: String
    var employees: [Employee] = []  // Aggregation - has employees
    
    init(name: String) {
        self.name = name
    }
    
    func addEmployee(_ employee: Employee) {
        employees.append(employee)
        print("\(employee.name) added to \(name) department")
    }
    
    func removeEmployee(_ employee: Employee) {
        employees.removeAll { $0.id == employee.id }
        print("\(employee.name) removed from \(name) department")
    }
    
    func listEmployees() {
        print("\n\(name) Department Employees:")
        for employee in employees {
            print("- \(employee.name) (\(employee.position))")
        }
    }
}

// Usage
let emp1 = Employee(name: "Alice Smith", position: "Developer", id: "E001")
let emp2 = Employee(name: "Bob Johnson", position: "Designer", id: "E002")
let emp3 = Employee(name: "Carol White", position: "Manager", id: "E003")

let itDepartment = Department(name: "IT")
itDepartment.addEmployee(emp1)
itDepartment.addEmployee(emp2)

let hrDepartment = Department(name: "HR")
hrDepartment.addEmployee(emp3)

itDepartment.listEmployees()

// Employees can exist independently even if department is destroyed
itDepartment.removeEmployee(emp1)
emp1.displayInfo()  // Employee still exists
```

### Real-World Example: Library and Books

```swift
class Book {
    var title: String
    var author: String
    var isbn: String
    
    init(title: String, author: String, isbn: String) {
        self.title = title
        self.author = author
        self.isbn = isbn
    }
}

class Library {
    var name: String
    var books: [Book] = []
    
    init(name: String) {
        self.name = name
    }
    
    func addBook(_ book: Book) {
        books.append(book)
        print("Added '\(book.title)' to \(name)")
    }
    
    func removeBook(_ book: Book) {
        books.removeAll { $0.isbn == book.isbn }
        print("Removed '\(book.title)' from \(name)")
    }
}

// Books exist independently
let book1 = Book(title: "1984", author: "George Orwell", isbn: "123")
let book2 = Book(title: "Brave New World", author: "Aldous Huxley", isbn: "456")

let library = Library(name: "City Library")
library.addBook(book1)
library.addBook(book2)

// Even if library is destroyed, books still exist
```

---

## 7. Composition

**Definition**: Composition is a strong form of aggregation representing a "part-of" relationship where the child cannot exist independently of the parent. If the parent is destroyed, the child is also destroyed.

### Key Concepts:
- Strong "has-a" relationship
- Child cannot exist without parent
- Parent owns the children
- Lifecycle dependency

### Example:

```swift
// House has Rooms - Rooms cannot exist without House (strong ownership)
class Room {
    var name: String
    var area: Double
    
    init(name: String, area: Double) {
        self.name = name
        self.area = area
        print("Room '\(name)' created")
    }
    
    deinit {
        print("Room '\(name)' destroyed")
    }
}

class House {
    var address: String
    private var rooms: [Room] = []  // Composition - House owns rooms
    
    init(address: String) {
        self.address = address
        // Create rooms as part of house
        self.rooms = [
            Room(name: "Living Room", area: 300),
            Room(name: "Bedroom", area: 200),
            Room(name: "Kitchen", area: 150)
        ]
        print("House at \(address) created with \(rooms.count) rooms\n")
    }
    
    func listRooms() {
        print("Rooms in house at \(address):")
        for room in rooms {
            print("- \(room.name): \(room.area) sq ft")
        }
    }
    
    deinit {
        print("\nHouse at \(address) destroyed")
        // Rooms will be automatically destroyed
    }
}

// Usage
do {
    let myHouse = House(address: "123 Main St")
    myHouse.listRooms()
    // When house goes out of scope, rooms are destroyed too
}
// House and all its rooms are destroyed here
```

### Real-World Example: Car and Engine

```swift
class Engine {
    var type: String
    var horsepower: Int
    
    init(type: String, horsepower: Int) {
        self.type = type
        self.horsepower = horsepower
        print("Engine created: \(type), \(horsepower)hp")
    }
    
    func start() {
        print("Engine started")
    }
    
    deinit {
        print("Engine destroyed")
    }
}

class CarWithEngine {
    var model: String
    private var engine: Engine  // Composition - Car owns engine
    
    init(model: String, engineType: String, horsepower: Int) {
        self.model = model
        // Engine is created as part of car
        self.engine = Engine(type: engineType, horsepower: horsepower)
        print("Car '\(model)' created\n")
    }
    
    func start() {
        print("Starting \(model)...")
        engine.start()
        print("\(model) is ready to drive!")
    }
    
    deinit {
        print("Car '\(model)' destroyed")
        // Engine will be automatically destroyed
    }
}

// Usage
do {
    let car = CarWithEngine(model: "Mustang", engineType: "V8", horsepower: 450)
    car.start()
}
print("\nCar destroyed, engine destroyed with it")
```

### Comparison: Association vs Aggregation vs Composition

```swift
// Association: Independent objects that interact
class Professor {
    var name: String
    init(name: String) { self.name = name }
}

class Course {
    var title: String
    init(title: String) { self.title = title }
    
    func addProfessor(_ professor: Professor) {
        print("\(professor.name) teaching \(title)")
    }
}

// Aggregation: Parent has children, but children can exist independently
class Team {
    var name: String
    var players: [Player] = []
    init(name: String) { self.name = name }
}

class Player {
    var name: String
    init(name: String) { self.name = name }
}

// Composition: Parent owns children, children cannot exist without parent
class Computer {
    var model: String
    private var cpu: CPU  // CPU is part of computer
    
    init(model: String) {
        self.model = model
        self.cpu = CPU(cores: 8)  // Created with computer
    }
}

class CPU {
    var cores: Int
    init(cores: Int) { self.cores = cores }
}
```

---

## 8. Coupling and Cohesion

### Coupling

**Definition**: Coupling refers to the degree of interdependence between software modules. Low coupling is desirable.

#### Types of Coupling:

```swift
// ‚ùå Tight Coupling (Bad)
class OrderProcessor {
    func processOrder() {
        let db = MySQLDatabase()  // Tightly coupled to MySQL
        db.connect()
        db.save()
    }
}

// ‚úÖ Loose Coupling (Good)
protocol Database {
    func connect()
    func save()
}

class OrderProcessorLoose {
    private let database: Database
    
    init(database: Database) {
        self.database = database  // Loosely coupled through protocol
    }
    
    func processOrder() {
        database.connect()
        database.save()
    }
}

// Can easily switch database implementations
class MySQLDatabase: Database {
    func connect() { print("MySQL connected") }
    func save() { print("Saved to MySQL") }
}

class MongoDatabase: Database {
    func connect() { print("MongoDB connected") }
    func save() { print("Saved to MongoDB") }
}
```

### Cohesion

**Definition**: Cohesion refers to how closely related and focused the responsibilities of a module are. High cohesion is desirable.

```swift
// ‚ùå Low Cohesion (Bad) - Class does too many unrelated things
class UserManager {
    func createUser() { }
    func deleteUser() { }
    func sendEmail() { }
    func generateReport() { }
    func processPayment() { }
}

// ‚úÖ High Cohesion (Good) - Each class has a single, focused responsibility
class UserService {
    func createUser() { }
    func deleteUser() { }
    func updateUser() { }
}

class EmailService {
    func sendEmail() { }
    func sendBulkEmail() { }
}

class ReportService {
    func generateUserReport() { }
    func generateSalesReport() { }
}

class PaymentService {
    func processPayment() { }
    func refundPayment() { }
}
```

---

## 9. Message Passing

**Definition**: Message passing is the process by which objects communicate with each other by sending and receiving messages (method calls).

### Example 1: Direct Message Passing

```swift
class Sender {
    func sendMessage(to receiver: Receiver, message: String) {
        print("Sender: Sending message '\(message)'")
        receiver.receiveMessage(message)
    }
}

class Receiver {
    func receiveMessage(_ message: String) {
        print("Receiver: Received message '\(message)'")
        processMessage(message)
    }
    
    private func processMessage(_ message: String) {
        print("Receiver: Processing '\(message)'")
    }
}

// Usage
let sender = Sender()
let receiver = Receiver()
sender.sendMessage(to: receiver, message: "Hello, World!")
```

### Example 2: Delegation Pattern (Message Passing)

```swift
protocol DownloadDelegate: AnyObject {
    func downloadDidStart()
    func downloadDidComplete(data: String)
    func downloadDidFail(error: String)
}

class Downloader {
    weak var delegate: DownloadDelegate?
    
    func startDownload(url: String) {
        print("Downloading from \(url)...")
        delegate?.downloadDidStart()
        
        // Simulate download
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            let success = Bool.random()
            if success {
                self.delegate?.downloadDidComplete(data: "Downloaded data")
            } else {
                self.delegate?.downloadDidFail(error: "Network error")
            }
        }
    }
}

class ViewController: DownloadDelegate {
    let downloader = Downloader()
    
    init() {
        downloader.delegate = self
    }
    
    func startDownloading() {
        downloader.startDownload(url: "https://example.com/file")
    }
    
    func downloadDidStart() {
        print("ViewController: Download started, showing loader...")
    }
    
    func downloadDidComplete(data: String) {
        print("ViewController: Download complete! Data: \(data)")
    }
    
    func downloadDidFail(error: String) {
        print("ViewController: Download failed: \(error)")
    }
}
```

### Example 3: Observer Pattern (Broadcast Messages)

```swift
protocol Observer: AnyObject {
    func update(message: String)
}

class Subject {
    private var observers: [Observer] = []
    
    func attach(observer: Observer) {
        observers.append(observer)
    }
    
    func detach(observer: Observer) {
        observers.removeAll { $0 === observer }
    }
    
    func notifyObservers(message: String) {
        print("Subject: Broadcasting message to \(observers.count) observers")
        for observer in observers {
            observer.update(message: message)
        }
    }
}

class ConcreteObserverA: Observer {
    var name: String
    
    init(name: String) {
        self.name = name
    }
    
    func update(message: String) {
        print("\(name): Received message '\(message)'")
    }
}

class ConcreteObserverB: Observer {
    var name: String
    
    init(name: String) {
        self.name = name
    }
    
    func update(message: String) {
        print("\(name): Got notification '\(message)'")
    }
}

// Usage
let subject = Subject()

let observer1 = ConcreteObserverA(name: "Observer A")
let observer2 = ConcreteObserverB(name: "Observer B")
let observer3 = ConcreteObserverA(name: "Observer C")

subject.attach(observer: observer1)
subject.attach(observer: observer2)
subject.attach(observer: observer3)

subject.notifyObservers(message: "State changed!")
```

---

## Summary

### Core 4 OOP Principles

#### Encapsulation
- **What**: Bundling data and methods, hiding internal details
- **Why**: Data protection, controlled access, easier maintenance
- **How**: Use access control (private, public, etc.)

#### Inheritance
- **What**: Creating new classes based on existing classes
- **Why**: Code reuse, establish hierarchical relationships
- **How**: Use class inheritance with `override` keyword

#### Polymorphism
- **What**: Same interface, different implementations
- **Why**: Flexibility, extensibility, code organization
- **How**: Method overriding, protocol conformance

#### Abstraction
- **What**: Hiding complexity, showing only essential features
- **Why**: Simplify complex systems, reduce coupling
- **How**: Use protocols to define interfaces

### Additional OOP Principles

#### Association
- **What**: "Uses-a" relationship between independent objects
- **Why**: Model interactions without ownership
- **How**: Objects reference and interact with each other

#### Aggregation
- **What**: "Has-a" relationship where child can exist independently
- **Why**: Model weak ownership relationships
- **How**: Parent contains references to children that can exist alone

#### Composition
- **What**: "Part-of" relationship where child cannot exist without parent
- **Why**: Model strong ownership and lifecycle dependencies
- **How**: Parent creates and owns children completely

### Design Principles

#### Coupling
- **Goal**: Achieve loose coupling
- **What**: Reduce interdependence between modules
- **How**: Use protocols, dependency injection

#### Cohesion
- **Goal**: Achieve high cohesion
- **What**: Keep related functionality together
- **How**: Single Responsibility Principle

#### Message Passing
- **What**: Communication between objects through method calls
- **Why**: Enable object interaction and collaboration
- **How**: Direct calls, delegation, observer pattern

---

## Best Practices

1. **Favor Composition over Inheritance**: Use composition and protocols when possible for better flexibility
2. **Achieve Loose Coupling**: Use protocols and dependency injection to reduce interdependence
3. **Maintain High Cohesion**: Keep related functionality together, follow Single Responsibility
4. **Use Access Control**: Properly use `private`, `internal`, `public`, `fileprivate` for encapsulation
5. **Protocol-Oriented Programming**: Swift emphasizes protocols over class inheritance
6. **Choose the Right Relationship**:
   - Use **Association** for independent objects that interact
   - Use **Aggregation** for "has-a" relationships with independent lifecycles
   - Use **Composition** for "part-of" relationships with dependent lifecycles
7. **Follow SOLID Principles**: 
   - **S**ingle Responsibility
   - **O**pen/Closed
   - **L**iskov Substitution
   - **I**nterface Segregation
   - **D**ependency Inversion
8. **Keep It Simple**: Don't over-engineer with unnecessary abstractions
9. **Use Delegation for Communication**: Implement message passing through protocols when appropriate
10. **Value Types vs Reference Types**: Consider using structs (value types) instead of classes when appropriate

---

## Additional Resources

- [Swift Programming Language Guide](https://docs.swift.org/swift-book/)
- [Protocol-Oriented Programming in Swift](https://developer.apple.com/videos/play/wwdc2015/408/)
- [Design Patterns in Swift](https://refactoring.guru/design-patterns/swift)

